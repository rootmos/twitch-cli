#!/usr/bin/env python3

import os
import uuid
import json
import requests
import dateutil.parser
import time
import concurrent.futures
import subprocess
import sys
import re
import argparse
import tempfile
import socket
import ssl
import select
import errno
import asyncio
import logging

from datetime import datetime, timedelta, timezone
from pathlib import Path
from urllib.parse import urlencode, urlparse, parse_qs
from http.server import ThreadingHTTPServer, BaseHTTPRequestHandler

client_id = "dqfe0to2kp1pj0yvs3rpvuupdn1u6d"
redirect_host = "localhost"
redirect_port = 37876
redirect_path = "/redirect"
redirect_uri = f"http://{redirect_host}:{redirect_port}{redirect_path}"

helix_url = "https://api.twitch.tv/helix"
kraken_url = "https://api.twitch.tv/kraken"
v5_url = "https://api.twitch.tv/v5"
oauth2_url = "https://id.twitch.tv/oauth2"
irc_addr = ("irc.chat.twitch.tv", 6697)

# utils

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def parse_duration(string):
    p = re.compile("([0-9]+)([dDhHmMsS])")
    secs = 0
    for m in p.finditer(string):
        n = int(m.group(1))
        t = m.group(2)
        if t == "s" or t == "S":
            secs += n
        elif t == "m" or t == "M":
            secs += n * 60
        elif t == "h" or t == "H":
            secs += n * 60 * 60
        elif t == "d" or t == "D":
            secs += n * 60 * 60 * 24
    return secs

def render_duration(secs):
    s = ""

    if secs >= 60 * 60 * 24:
        s += f"{secs // (60 * 60 * 24)}d"
        secs %= 60 * 60 * 24

    if secs >= 60 * 60:
        s += f"{secs // (60 * 60)}h"
        secs %= 60 * 60

    if secs >= 60:
        s += f"{secs // 60}m"
        secs %= 60

    if secs > 0:
        s += f"{secs}s"

    return s

# logging

logger = None
def setup_logger(level):
    l = logging.getLogger('twitch-cli')
    l.setLevel(level)

    ch = logging.StreamHandler()
    ch.setLevel(level)

    f = logging.Formatter(
        fmt='%(asctime)s:%(name)s:%(levelname)s %(message)s',
        datefmt='%Y-%m-%dT%H:%M:%S%z')
    ch.setFormatter(f)

    l.addHandler(ch)

    return l

# auth

def new_token(scope):
    state = str(uuid.uuid4())
    q = {
        "client_id": client_id,
        "redirect_uri": redirect_uri,
        "response_type": "token",
        "scope": scope,
        "state": state,
    }

    url = f"{oauth2_url}/authorize?{urlencode(q)}"

    eprint(url)
    os.system(f"xdg-open '{url}'")

    token = None

    class RequestHandler(BaseHTTPRequestHandler):
        protocol_version = 'HTTP/1.1'

        def do_GET(self):
            p = urlparse(self.path)

            if p.path != redirect_path:
                self.send_response(404)
                self.send_header("Content-Length", 0)
                self.end_headers()
                return

            body = '<html>' \
                   '<body>' \
                   '<script>' \
                   'var xhr = new XMLHttpRequest();' \
                   'xhr.open("POST", "/token", true);' \
                   'xhr.setRequestHeader("Content-Type", "application/json");' \
                   'xhr.onreadystatechange = function () {' \
                       'if (xhr.readyState === 4 && xhr.status === 204) {' \
                            'document.write("ok");' \
                       '}' \
                   '};' \
                   'p = new URLSearchParams(document.location.hash.substring(1));' \
                   'xhr.send(JSON.stringify({"token": p.get("access_token"), "state": p.get("state")}));' \
                   '</script>' \
                   '</body>' \
                   '</html>'

            body = body.encode("UTF-8")

            self.send_response(200)
            self.send_header("Content-Type", "text/html")
            self.send_header("Content-Length", len(body))
            self.end_headers()
            self.wfile.write(body)

        def do_POST(self):
            p = urlparse(self.path)
            if p.path != "/token":
                self.send_response(404)
                self.send_header("Content-Length", 0)
                self.end_headers()
                return

            l = int(self.headers["Content-Length"])
            r = json.loads(self.rfile.read(l))

            if r["state"] != state:
                self.send_response(400)
                self.send_header("Content-Length", 0)
                self.end_headers()
                return

            nonlocal token
            token = r["token"]
            self.send_response(204)
            self.send_header("Content-Length", 0)
            self.end_headers()

    with ThreadingHTTPServer((redirect_host, redirect_port), RequestHandler) as s:
        s.timeout = 0.2
        while token is None:
            s.handle_request()

    if token is None:
        raise RuntimeError("unable to obtain token")

    return token

# the client

class Client:
    def __init__(self, token):
        self._me = None
        self.token = token
        self._channels = {}

    @staticmethod
    def fetch_token(scopes, token_path):
        if token_path.exists():
            with token_path.open() as f: s = json.loads(f.read())
        else:
            s = {}

        scope = " ".join(sorted(scopes))
        if scope not in s:
            s[scope] = new_token(scope)
            with token_path.open("w") as f: f.write(json.dumps(s))

        return s[scope]

    @property
    def me(self):
        if self._me is None:
            h = { "Authorization": f"OAuth {self.token}" }
            r = requests.get(f"{oauth2_url}/validate", headers=h)
            r.raise_for_status()
            j = r.json()
            self._me = User(self, user_name=j["login"], user_id=j["user_id"])
            self.scopes = j["scopes"]

            logger.info(f"authenticated as {self._me.user_name} ({self._me.user_id}) with scopes: {' '.join(self.scopes)}")
            exp = j["expires_in"]
            if exp / 3600 < 24:
                logger.warning(f"access token expries soon: {render_duration(exp)}")
            else:
                logger.debug(f"access token expries in {render_duration(exp)}")

        return self._me

    def put(self, url, body=None, kraken=False):
        if kraken:
            url = kraken_url + url
            h = {
                "Authorization": f"OAuth {self.token}",
                "Client-ID": client_id,
                "Accept": "application/vnd.twitchtv.v5+json",
            }
        else:
            url = helix_url + url
            h = {
                "Authorization": f"Bearer {self.token}",
                "Client-ID": client_id,
            }

        r = requests.put(url, json=body, headers=h)
        r.raise_for_status()

    def delete(self, url, body=None, kraken=False):
        if kraken:
            url = kraken_url + url
            h = {
                "Authorization": f"OAuth {self.token}",
                "Client-ID": client_id,
                "Accept": "application/vnd.twitchtv.v5+json",
            }
        else:
            url = helix_url + url
            h = {
                "Authorization": f"Bearer {self.token}",
                "Client-ID": client_id,
            }

        r = requests.delete(url, json=body, headers=h)
        r.raise_for_status()

    def post(self, url, body=None, kraken=False):
        if kraken:
            url = kraken_url + url
            h = {
                "Authorization": f"OAuth {self.token}",
                "Client-ID": client_id,
                "Accept": "application/vnd.twitchtv.v5+json",
            }
        else:
            url = helix_url + url
            h = {
                "Authorization": f"Bearer {self.token}",
                "Client-ID": client_id,
            }

        r = requests.post(url, json=body, headers=h)
        r.raise_for_status()

    def get(self, url, params=None, kraken=False, v5=False):
        if kraken:
            url = kraken_url + url
            h = {
                "Authorization": f"OAuth {self.token}",
                "Client-ID": client_id,
                "Accept": "application/vnd.twitchtv.v5+json",
            }
        elif v5:
            url = v5_url + url
            params = params or {}
            params["client_id"] = client_id
            h = None
        else:
            url = helix_url + url
            h = {
                "Authorization": f"Bearer {self.token}",
                "Client-ID": client_id,
            }

        while True:
            r = requests.get(url, params=params, headers=h)
            if r.status_code == 429:
                l = r.headers["Ratelimit-Limit"]
                t = int(r.headers["Ratelimit-Reset"])
                w = (t - time.time()) / 10
                eprint(f"calm down! limit={l} reset={t} wait={w}")
                time.sleep(w)
                continue

            r.raise_for_status()
            return r.json()

    def streams(self, user):
        try:
            users = list(user)
        except TypeError:
            users = [user]

        ss = []
        while len(users) > 0:
            p = { "user_id": [u.user_id for u in users[:100]] }
            while True:
                j = self.get("/streams", params=p)
                for i in j["data"]:
                    ss.append(Stream.from_twitch_json(self, i))
                if "cursor" not in j["pagination"]: break
                p["after"] = j["pagination"]["cursor"]
            users = users[100:]

        return ss

    def user(self, *names):
        us = []
        while len(names) > 0:
            p = { "login": names[:100] }
            j = self.get("/users", params=p)
            for i in j["data"]:
                us.append(User.from_twitch_json(self, i))
            names = names[100:]

        return us

    def channel(self, channel_id):
        if channel_id not in self._channels:
            logger.debug(f"fetching channel info: {channel_id}")
            self._channels[channel_id] = Channel.from_twitch_json(self, self.get(f"/channels/{channel_id}", kraken=True))
        return self._channels[channel_id]

    def follow(self, *channels):
        for u in self.user(*channels):
            self.put(f"/users/{self.me.user_id}/follows/channels/{u.user_id}", kraken=True)
            logger.info(f"followed {u.user_name} ({u.user_id})")

    def unfollow(self, *channels):
        for u in self.user(*channels):
            self.delete(f"/users/{self.me.user_id}/follows/channels/{u.user_id}", kraken=True)
            logger.info(f"unfollowed {u.user_name} ({u.user_id})")

    def webhook(self, topic, callback, secret, lease_seconds=180):
        body = {
            "hub.topic": topic,
            "hub.callback": callback,
            "hub.mode": "subscribe",
            "hub.lease_seconds": lease_seconds,
            "hub.secret": secret,
        }

        self.post(f"/webhooks/hub", body=body)

    def comments(self, video_id):
        p = {"limit": 100}
        n = 0
        last = None
        while True:
            j = self.get(f"/videos/{video_id}/comments", v5=True, params=p)
            for c in j["comments"]:
                n += 1
                last = Comment.from_twitch_json(self, c)
                yield last

            if "_next" not in j: break
            p["cursor"] = j["_next"]
            logger.info(f"comments fetching progress: video_id={video_id} n={n} offset={render_duration(int(last.offset))}")
        logger.info(f"comments fetching completed: video_id={video_id} n={n}")

    def video(self, *video_ids):
        vs = []
        while len(video_ids) > 0:
            p = { "id": video_ids[:100], "first": 100, "sort": "time" }
            j = self.get("/videos", params=p)
            for i in j["data"]:
                vs.append(Video.from_twitch_json(self, i))

            video_ids = video_ids[100:]
        return vs

class User:
    def __init__(self, client, user_id, user_name, bio=None):
        self.client = client
        self.user_id = user_id
        self.user_name = user_name
        self.bio = bio
        self._channel = None

    def __str__(self):
        return self.user_name

    def __repr__(self):
        return f"{self.user_name} ({self.user_id})"

    @staticmethod
    def from_twitch_json(client, j):
        if "login" in j:
            return User(client, user_id=j["id"], user_name=j["login"])
        elif "_id" in j:
            return User(client, user_id=j["_id"], user_name=j["display_name"], bio=j["bio"])
        else:
            return User(client, user_id=j["user_id"], user_name=j["user_name"])

    @property
    def channel(self):
        if self._channel is None:
            self._channel = self.client.channel(self.user_id)

        return self._channel

    def following(self):
        p = { "from_id": self.user_id, "first": 100 }
        us = []
        while True:
            j = self.client.get("/users/follows", params=p)
            for i in j["data"]:
                us.append(User(self.client, user_id=i["to_id"], user_name=i["to_name"]))

            if len(us) == j["total"]: break

            if "cursor" not in j["pagination"]: break
            p["after"] = j["pagination"]["cursor"]

        return sorted(us, key=lambda u: u.user_name.lower())

    def videos(self, since=None):
        p = { "user_id": self.user_id, "first": 10, "sort": "time" }
        vs = []
        while True:
            j = self.client.get("/videos", params=p)
            for i in j["data"]:
                v = Video.from_twitch_json(self, i)
                if since is not None and v.created_at < since:
                    return vs
                vs.append(v)

            if "cursor" not in j["pagination"]: break
            p["after"] = j["pagination"]["cursor"]

        return vs

class Channel:
    def __init__(self, client, channel_id, channel_name, status, game, followers, views):
        self.client = client
        self.channel_id = channel_id
        self.channel_name = channel_name
        self._status = status
        self._game = game
        self.followers = followers
        self.views = views

    def _setter(self, k, v):
        self.client.put(
            f"/channels/{self.channel_id}",
            body={f"channel[{k}]": v},
            kraken=True,
        )
        return v

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, v):
        self._status = self._setter("status", v)

    @property
    def game(self):
        return self._game

    @game.setter
    def game(self, v):
        self._game = self._setter("game", v)

    @staticmethod
    def from_twitch_json(client, j):
        return Channel(client,
            channel_id = j["_id"],
            channel_name = j["name"],
            status = j["status"],
            game = j["game"],
            followers = j["followers"],
            views = j["views"],
        )

    def to_dict(self):
        return {
            "channel_id": self.channel_id,
            "title": self.status,
            "category": self.game,
            "followers": self.followers,
            "views": self.views,
        }

class Video:
    def __init__(self, client, video_id, title, user, url, created_at, published_at, duration, typ):
        self.client = client
        self.video_id = video_id
        self.title = title
        self.user = user
        self.url = url
        self.created_at = created_at
        self.published_at = published_at
        self.duration = duration
        self.typ = typ
        self._comments = None

    def __str__(self):
        return self.title

    def __repr__(self):
        return f"{self.user.user_name}: {self.title} ({self.video_id})"

    @property
    def comments(self):
        if self._comments is None:
            self._comments = self.client.comments(self.video_id)
        return self._comments

    def from_twitch_json(client, j):
        if "created_at" in j and j["created_at"] is not None:
            created_at = dateutil.parser.isoparse(j["created_at"])
        else:
            created_at = None

        if "published_at" in j and j["published_at"] is not None:
            published_at = dateutil.parser.isoparse(j["published_at"])
        else:
            published_at = None

        return Video(client,
            video_id=j["id"],
            title=j["title"],
            url=j["url"],
            user=User.from_twitch_json(client, j),
            created_at=created_at,
            published_at=published_at,
            duration=parse_duration(j["duration"]),
            typ=j["type"],
        )

    def to_dict(self):
        return {
            "video_id": self.video_id,
            "user_id": self.user.user_id,
            "user_name": self.user.user_name,
            "created_at": self.created_at.isoformat(),
            "published_at": self.published_at.isoformat(),
            "title": self.title,
            "url": self.url,
            "type": self.typ,
            "duration": self.duration,
            "duration_human": render_duration(self.duration),
        }

class Stream:
    def __init__(self, client, user, title):
        self.client = client
        self.user = user
        self.title = title

    def __str__(self):
        return self.title

    def __repr__(self):
        return f"{self.user.user_name}: {self.title}"

    @property
    def url(self):
        return f"https://twitch.tv/{self.user.user_name}"

    @staticmethod
    def from_twitch_json(client, j):
        return Stream(client,
            title=j["title"],
            user=User.from_twitch_json(client, j),
        )

class Comment:
    def __init__(self, client, body, channel=None, channel_name=None, comment_id=None, user=None, created_at=None, offset=None):
        self.client = client
        self.comment_id = comment_id
        self.user = user
        self.created_at = created_at or datetime.now(timezone.utc)
        self.offset = offset
        self.body = body
        self.channel = channel
        if self.channel is not None:
            self.channel_name = self.channel.channel_name
        else:
            self.channel_name = channel_name

    @staticmethod
    def from_twitch_json(client, j):
        offset = j["content_offset_seconds"]
        return Comment(
            client = client,
            comment_id = j["_id"],
            user = User.from_twitch_json(client, j["commenter"]),
            created_at = dateutil.parser.isoparse(j["created_at"]),
            offset = offset,
            body = j["message"]["body"],
            channel = client.channel(j["channel_id"]),
        )

    def srt(self, i, duration):
        def fmt(td):
            h = int(td/3600); td -= h*3600
            m = int(td/60); td -= m*60
            s = int(td); td -= s
            ms = int(td*1000)
            return f"{h:02}:{m:02}:{s:02},{ms:03}"

        s  = f"{i}\n"
        s += f"{fmt(self.offset)} --> {fmt(self.offset + duration)}\n"
        s += f"{self.user.user_name}: {self.body}\n\n"
        return s

def tabularize(rows, pad=" ", sep=" "):
    if len(rows) == 0:
        return []

    s = [0] * max([len(r) for r in rows])
    for r in rows:
        for i, c in enumerate(r):
            s[i] = max(s[i], len(c))

    ls = []
    for r in rows:
        l = ""
        for i, c in enumerate(r):
            if i + 1 < len(r):
                l += c.ljust(s[i], pad[0]) + sep
            else:
                l += c
        ls.append(l)
    return ls

def dmenu(choices, lines=20):
    d = {}
    if all([isinstance(c, tuple) for c in choices]):
        cs = tabularize([l for (l, v) in choices])
        for i, c in enumerate(cs):
            d[c] = choices[i][1]
        stdin = '\n'.join(cs)
    else:
        for c in choices:
            d[c] = c
        stdin = '\n'.join(choices)

    p = subprocess.Popen(f"dmenu -l {lines}", shell=True, text=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    (selection, _) = p.communicate(input=stdin)
    vs = []
    for l in selection.splitlines():
        vs.append(d[l])
    return vs

def edit(v):
    with tempfile.NamedTemporaryFile() as f:
        f.write(bytes(v, "UTF-8"))
        f.flush()

        e = os.getenv("EDITOR", "vi")
        if e == "vi" or e == "vim":
            os.system(f"{e} -b {f.name}")
        else:
            os.system(f"$EDITOR -b {f.name}")

        f.seek(0)
        return str(f.read(), "UTF-8")

class IRCMessage:
    def __init__(self, bs):
        self.raw = bs
        s = str(bs, "UTF-8")
        self.tags, s = IRCMessage.__parse_tags(s)
        self.prefix, s = IRCMessage.__parse_prefix(s)
        self.command, s = IRCMessage.__parse_command(s)
        self.params, self.trailing = IRCMessage.__parse_params(s, [])

    def __repr__(self):
        props = []
        if self.prefix is not None: props.append(f"prefix={self.prefix}")
        if self.tags is not None: props.append(f"tags={self.tags}")
        if self.command is not None: props.append(f"command={self.command}")
        if len(self.params) > 0: props.append(f"params={self.params}")
        if self.trailing is not None: props.append(f"trailing={self.trailing}")
        return f"IRCMessage({','.join(props)})"

    def __parse_prefix(s):
        if s[0] == ':':
            i = s.index(' ')
            return s[1:i], s[i:]
        else:
            return None, s

    def __parse_command(s):
        m = re.match("[ ]*(\w+)|(\d\d\d)", s)
        cmd = m.group(1)
        return cmd, s[len(m.group(0)):]

    def __parse_params(s, acc):
        if s == "" or re.fullmatch("[ ]+", s):
            return acc, None

        m = re.fullmatch("[ ]+:(.*)", s)
        if m:
            return acc, m.group(1)
        else:
            m = re.match("[ ]+([^ :][^ ]*)(.*)", s)
            if m is None:
                raise ValueError(f"<params> don't match: {s}")
            middle = m.group(1)
            acc.append(middle)
            return IRCMessage.__parse_params(m.group(2), acc)

    def __parse_tags(s):
        if s[0] != '@':
            return {}, s
        else:
            return IRCMessage.__parse_tag(s[1:], {})

    def __parse_tag(s, acc):
        p = re.compile("(\\+?([a-zA-Z0-9\\-]+/)?[a-zA-Z0-9\\-]+)(=([^ ;]*))?[ ;]")
        m = p.match(s)
        if m is None: return acc, s
        acc[m.group(1)] = m.group(4)
        return IRCMessage.__parse_tag(s[m.end(0):], acc)

class Chat:
    def __init__(self, client, channels, reader, writer, output, subtitles, start, duration):
        self.client = client
        self.reader = reader
        self.writer = writer
        self.queue = asyncio.Queue()
        self.output = output
        self._print_comment = self._write_subtitle if subtitles else self._write_plain
        self.start = start
        self.comments_count = 0
        self.duration = duration

        if len(channels) == 0:
            self.channels = [ self.client.me.user_name ]
        else:
            self.channels = [ u.user_name for u in self.client.user(*channels) ]

        self.rooms = {}
        for c in self.channels:
            self.rooms[f"#{c}"] = set()

        self.rooms_update_lock = asyncio.Lock()
        self.rooms_update_snapshot = None

    async def send_line(self, line):
        await self.queue.put(bytes(line + "\r\n", "UTF-8"))

    async def _channel_input(self, channel, path):
        logger.debug(f"reading chat input to {channel} from: {path}")
        async def go(r, w):
            logger.debug(f"client connected to chat input for {channel}")
            while True:
                w.write(bytes(f"{self.client.me.user_name}@{channel} ", "UTF-8"))
                l = await r.readline()
                if len(l) == 0: break
                if len(l) == 1: continue
                l = str(l[:-1], "UTF-8")
                logger.debug(f"sending chat line to {channel}: {l}")
                await self.send_line(f"PRIVMSG #{channel} :{l}")
                await self._print_comment(Comment(user=self.client.me, channel_name=channel, body=l))
            logger.debug(f"client disconnected for chat input to {channel}")

        await asyncio.start_unix_server(go, path)

    async def _write_plain(self, comment):
        self.comments_count += 1
        d = comment.created_at.isoformat(timespec='seconds')

        if comment.user is None:
            if len(self.channels) > 1:
                self.output.write(f"{d} {comment.channel_name} {comment.body}\n")
            else:
                self.output.write(f"{d} {comment.body}\n")
        else:
            if len(self.channels) > 1:
                self.output.write(f"{d} {comment.channel_name} {comment.user.user_name}: {comment.body}\n")
            else:
                self.output.write(f"{d} {comment.user.user_name}: {comment.body}\n")
        self.output.flush()

    async def _write_subtitle(self, comment):
        self.comments_count += 1
        self.output.write(comment.srt(self.comments_count, self.duration))
        self.output.flush()

    @staticmethod
    def extract_user_name_from_prefix(p):
        u = re.match("([-\\w]+)!([-\\w]+)@([-\\w]+).tmi.twitch.tv", p)
        if u.group(1) == u.group(2) and u.group(2) == u.group(3):
            return u.group(1)
        raise ValueError(f"cannot extract user name from prefix: {p}")

    async def _perform_room_update(self):
        await asyncio.sleep(0.3)
        diffs = {}
        async with self.rooms_update_lock:
            for c in self.rooms.keys():
                j = set(self.rooms[c])
                j -= self.rooms_update_snapshot[c]
                l = set(self.rooms_update_snapshot[c])
                l -= self.rooms[c]
                diffs[c] = (j, l)

            self.rooms_update_snapshot = None

        for c, (j, l) in diffs.items():
            if len(j) > 0:
                body = "joined: " + " ".join(j)
            if len(l) > 0:
                body = "left: " + " ".join(l)
            await self._print_comment(Comment(self.client, channel_name=c, body=body))

    async def _handle_message(self, msg, join_parts=False):
        if msg.command == "PING":
            await self.send_line(f"PONG {msg.trailing}")
            return

        if msg.command == "JOIN" or msg.command == "PART":
            u = Chat.extract_user_name_from_prefix(msg.prefix)
            async with self.rooms_update_lock:
                if join_parts:
                    if self.rooms_update_snapshot is None:
                        self.rooms_update_snapshot = {}
                        for c in self.rooms.keys():
                            self.rooms_update_snapshot[c] = set(self.rooms[c])
                        asyncio.create_task(self._perform_room_update())
                if msg.command == "JOIN":
                    self.rooms[msg.params[0]].add(u)
                elif msg.command == "PART":
                    self.rooms[msg.params[0]].remove(u)
        elif msg.command == "353":
            for u in msg.trailing.split():
                self.rooms[msg.params[2]].add(u)
        elif msg.command == "366":
            pass
        elif msg.command == "PRIVMSG":
            d = datetime.fromtimestamp(int(msg.tags["tmi-sent-ts"])/1000, tz=timezone.utc)
            u = User(self.client, user_id=msg.tags["user-id"], user_name=msg.tags["display-name"])
            c = Comment(self.client,
                comment_id = msg.tags["id"],
                user = u,
                created_at = d,
                offset = (d - self.start).total_seconds(),
                channel_name = msg.params[0],
                body = msg.trailing,
            )
            await self._print_comment(c)
        elif msg.command == "USERSTATE":
            pass
        elif msg.command == "ROOMSTATE":
            pass
        elif msg.command == "CAP":
            pass
        elif msg.command == "001" or msg.command == "002" or msg.command == "003" or msg.command == "004":
            pass
        elif msg.command == "375" or msg.command == "372" or msg.command == "376":
            pass
        else:
            logger.debug(f"unhandled command: {msg.command}")

    @staticmethod
    async def run(client, channels, output, subtitles=False, duration=None, read_only=True, join_parts=False, input_path=None, start=None):
        r, w = await asyncio.open_connection(
            host = irc_addr[0], port = irc_addr[1],
            family = socket.AF_INET,
            ssl = True
        )

        if start:
            logger.debug(f"comments will be offset against: {start}")

        ctx = Chat(
            channels = channels,
            client = client,
            reader = r,
            writer = w,
            output = output,
            subtitles = subtitles,
            duration = duration,
            start = start or datetime.now(timezone.utc),
        )

        if not read_only:
            os.makedirs(input_path, exist_ok=True)
            inputs = [ ctx._channel_input(c, os.path.join(input_path, c)) for c in channels ]
        else:
            inputs = []

        await ctx.send_line(f"PASS oauth:{ctx.client.token}")
        await ctx.send_line(f"NICK {ctx.client.me.user_name}")
        await ctx.send_line("CAP REQ :twitch.tv/membership twitch.tv/commands twitch.tv/tags")

        for c in ctx.channels:
            await ctx.send_line(f"JOIN #{c}")

        async def do_read():
            while True:
                bs = await ctx.reader.readuntil(separator=b'\r\n')
                bs = bs[:-2]
                logger.debug(f"received IRC message: {bs}")
                await ctx._handle_message(IRCMessage(bs), join_parts=join_parts)

        async def do_write():
            while True:
                bs = await ctx.queue.get()
                ctx.writer.write(bs)
                ctx.queue.task_done()
                logger.debug(f"sending IRC message: {bs}")

        await asyncio.gather(do_read(), do_write(), *inputs)


import websockets
async def activity_feed(client, args):
    base = "wss://ws.twitch.rootmos.io"
    url = base + "/sessions"

    us = client.user(args.channels)

    async with websockets.connect(url) as ws:
        session = json.loads(await ws.recv())["session"]

        follows_base_url = "https://api.twitch.tv/helix/users/follows"
        streams_base_url = "https://api.twitch.tv/helix/streams"

        for u in us:
            topics = []
            if "follow" in args.event:
                topics.append(f"{follows_base_url}?first=1&to_id={u.user_id}")
            if "live" in args.event:
                topics.append(f"{streams_base_url}?user_id={u.user_id}")

            for t in topics:
                logger.debug(f"subscribing to topic: {t}")
                await ws.send(json.dumps({"subscription": {"topic": t}}))

        while True:
            e = json.loads(await ws.recv())

            if "subscription" in e:
                sub = e["subscription"]
                state, topic, callback, secret = sub["state"], sub["topic"], sub["callback_url"], sub["secret"]
                if state == "UNVERIFIED":
                    logger.debug(f"verifying topic: topic={topic} callback={callback}")
                    c.webhook(topic=topic, callback=callback, secret=secret)
                elif state == "VERIFIED":
                    logger.debug(f"verified topic: {topic}")

                    async def resub(delay, topic, callback, secret):
                        if delay > 0:
                            logger.debug(f"resubscription timer: seconds={delay} topic={topic}")
                            await asyncio.sleep(delay)
                        logger.debug(f"resubscribing: topic={topic}")
                        c.webhook(topic=topic, callback=callback, secret=secret)

                    eat = datetime.fromisoformat(sub["expires_at"])
                    vat = datetime.fromisoformat(sub["verified_at"])
                    now = datetime.now(timezone.utc)
                    delay = ((vat + (eat-vat)*0.75) - now).total_seconds()
                    asyncio.ensure_future(resub(delay, topic, callback, secret))
                elif state == "DENIED":
                    logger.debug(f"denied subscription: topic={topic} reason={sub['reason']}")
                elif state == "TIMEDOUT":
                    logger.warning(f"subscription timedout: topic={topic}")
                else:
                    logger.error(f"unexpected subscription state: state={state} topic={topic}")
            elif "event" in e:
                topic = e["event"]["topic"]
                payload = e["event"]["payload"]
                if topic.startswith(follows_base_url):
                    ts = datetime.strptime(payload["followed_at"], "%Y-%m-%dT%H:%M:%S%z").astimezone()
                    d = ts.replace(tzinfo=None).isoformat(timespec='seconds')
                    f = payload["from_name"]
                    t = payload["to_name"]

                    if args.notify_follow:
                        cmd = args.notify_follow.replace("%c", t).replace("%u", f)
                        logger.debug(f"running notify follow hook: {cmd}")
                        os.system(cmd)

                    print(f"{d} {f} followed {t}")
                elif topic.startswith(streams_base_url) and payload["type"] == "live":
                    ts = datetime.strptime(payload["started_at"], "%Y-%m-%dT%H:%M:%S%z").astimezone()
                    d = ts.replace(tzinfo=None).isoformat(timespec='seconds')
                    ch = payload["user_name"]
                    t = payload["title"]

                    if args.notify_live:
                        cmd = args.notify_live.replace("%c", ch).replace("%t", t)
                        logger.debug(f"running notify follow hook: {cmd}")
                        os.system(cmd)

                    print(f"{d} {ch} went live: {t}")
                else:
                    logger.warning(f"unhandled event: {e}")
            else:
                logger.warning(f"unexpected message: {e}")

def parse_args():
    parser = argparse.ArgumentParser(description="Twitch command line interface")
    subparsers = parser.add_subparsers(help="sub-commands", dest='command')

    default_config_path = "~/.twitch-cli"
    default_activity_events = ["live", "follow"]
    default_notify_live_command = "notify-send --app-name=twitch '%c went live' '%t'"
    default_notify_follow_command = "notify-send --app-name=twitch '%u followed %c'"

    parser.add_argument("--log", default="WARN", help="set log level")
    parser.add_argument("--config-path", metavar="CONFIG_PATH", help=f"configuration base path (default: {default_config_path})")
    parser.add_argument("--token-path", help=f"token path (default: CONFIG_PATH/tokens.json)")

    def add_json_argument(p):
        p.add_argument("--json", help="output json", action="store_true")
    def add_menu_argument(p):
        p.add_argument("--menu", help="run dmenu", action="store_true")
        p.add_argument("--menu-lines", type=int, default=20,
                help="number of maximum lines in the menu")

    activity = subparsers.add_parser("activity", help="activity feed")
    activity.add_argument("channels", metavar="CHANNEL", nargs="+",
            help="follow activity feed of CHANNEL")
    activity.add_argument("--event", metavar="EVENT", default=default_activity_events, nargs="*",
            help=f"event types: {','.join(default_activity_events)}")
    activity.add_argument("--notify-live", metavar="COMMAND", default=False, nargs="?",
            help=f"command to run when channel goes live (%%c replaced with channel name, %%t with the stream title)")
    activity.add_argument("--notify-follow", metavar="COMMAND", default=False, nargs="?",
            help=f"command to run when channel goes live (%%c is replaced with channel name, %%u with user name)")

    follow = subparsers.add_parser("follow", help="follow channel(s)")
    follow.add_argument("channels", metavar="CHANNEL", nargs="+", help="follow CHANNEL")

    unfollow = subparsers.add_parser("unfollow", help="unfollow user(s)")
    unfollow.add_argument("channels", metavar="CHANNEL", nargs="+", help="unfollow CHANNEL")

    following = subparsers.add_parser("following", help="list followed users")
    add_json_argument(following)
    add_menu_argument(following)

    list_parser = subparsers.add_parser("list", aliases=["live"], help="list live streams and videos (default)")
    list_parser.add_argument("channels", metavar="CHANNEL", nargs="*",
            help="list streams and videos of CHANNEL (defaults to followed channels)")
    list_parser.add_argument("--live", action="store_true", help="list only live streams (synonym for --since=0)")
    list_parser.add_argument("--since", type=int, default=3, help="days to list videos")
    list_parser.add_argument("--exclude", metavar="PATH",
            help=f"exclude channel if it appears in the specified file (default: CONFIG_PATH/exclude)")
    list_parser.add_argument("--title-max-length", type=int, default=80,
            help="maximum length of printed titles")
    add_json_argument(list_parser)
    add_menu_argument(list_parser)

    chat = subparsers.add_parser("chat", help="interact with chat")
    chat.add_argument("channels", metavar="CHANNEL", nargs="*",
            help="join CHANNEL's chat")
    chat.add_argument("--input-path", metavar="PATH",
            help=f"create chat input channel at PATH/CHANNEL (default: CONFIG_PATH/channel)")
    chat.add_argument("--read-only", action="store_true", default=False,
            help="lurker mode")
    chat.add_argument("--join-parts", action="store_true", default=False,
            help="display who joins and leaves the chat")

    stream = subparsers.add_parser("stream", help="manage stream")
    stream_actions = stream.add_subparsers(help="management actions", dest='stream_action')

    title_parser = stream_actions.add_parser("title", help="print stream title")
    add_json_argument(title_parser)

    set_title_parser = stream_actions.add_parser("set-title", help="set stream title")
    set_title_parser.add_argument("title", metavar="TITLE", help="set stream title to TITLE")

    edit_title_parser = stream_actions.add_parser("edit-title", help="edit stream title using $EDITOR")

    category_parser = stream_actions.add_parser("category", help="print stream category")
    add_json_argument(category_parser)

    set_category_parser = stream_actions.add_parser("set-category", help="set stream category")
    set_category_parser.add_argument("category", metavar="CATEGORY", help="set stream category to CATEGORY")

    edit_category_parser = stream_actions.add_parser("edit-category", help="edit stream category using $EDITOR")

    status_parser = stream_actions.add_parser("status", help="print stream status")
    add_json_argument(status_parser)

    comments = subparsers.add_parser("comments", help="download comments")
    comments.add_argument("content", metavar="CONTENT", nargs=1, help="fetch comments of CONTENT (either a channel or a video id)")
    comments.add_argument("--duration", type=float, default=10.0, help="comment display duration")
    comments.add_argument("--output", help="save to file instead of stdout")
    comments.add_argument("--start", metavar="DATETIME", help="offset comments relative to DATETIME")

    args = parser.parse_args()
    if args.command is None:
        args = parser.parse_args(["list"])

    if args.config_path is None:
        args.config_path = Path(default_config_path).expanduser()

    if args.token_path is None:
        args.token_path = args.config_path / "tokens.json"

    if args.command == "live":
        args.command = "list"
        args.since = 0

    if args.command == "list":
        if args.exclude is None:
            args.exclude = args.config_path / "exclude"

        if args.live:
            args.since = 0

    if args.command == "chat":
        if args.input_path is None:
            args.input_path = args.config_path / "channel"

    if args.command == "activity":
        if args.notify_live is None:
            args.notify_live = default_notify_live_command

        if args.notify_follow is None:
            args.notify_follow = default_notify_follow_command

    if args.command == "comments":
        args.start = datetime.fromisoformat(args.start) if args.start else None

    return args

if __name__ == "__main__":
    args = parse_args()
    logger = setup_logger(args.log.upper())

    scopes = []
    if args.command in ["follow", "unfollow"]:
        scopes.append("user_follows_edit")
    if args.command == "chat":
        scopes.append("chat:read")
        if not args.read_only:
            scopes.append("chat:edit")
    if args.command == "comments":
        scopes.append("chat:read")
    if args.command == "stream":
        if args.stream_action in ["set-title", "edit-title", "set-category", "edit-category"]:
            scopes.append("channel_editor")
    c = Client(token=Client.fetch_token(scopes=scopes, token_path=args.token_path))

    if args.command == "activity" or args.command == "chat":
        loop = asyncio.get_event_loop()

        # TODO: make it possible to run both acivity and chat (how to handle the options nicely?)
        if args.command == "activity":
            loop.create_task(activity_feed(client=c, args=args))

        if args.command == "chat":
            loop.create_task(Chat.run(
                client = c,
                channels = args.channels,
                input_path = args.input_path,
                read_only = args.read_only,
                output = sys.stdout
            ))

        try:
            loop.run_forever()
        except KeyboardInterrupt:
            logger.debug("received keyboard interrupt: stopping")
            loop.stop()
    elif args.command == "follow":
        c.follow(*args.channels)
    elif args.command == "unfollow":
        c.unfollow(*args.channels)
    elif args.command == "following":
        fs = c.me.following()
        if args.menu:
            for c in dmenu([f.user_name for f in fs], lines=args.menu_lines): print(c)
        else:
            if args.json:
                for f in fs: print('"' + f.user_name + '"')
            else:
                for f in fs: print(f.user_name)
        run_default_action = False
    elif args.command == "list":
        if args.exclude is not None and os.path.exists(args.exclude):
            with open(args.exclude, "r") as f:
                logger.debug(f"excluding channels listed in: {f.name}")
                exclude = [ l.strip().lower() for l in f ]
                logger.debug(f"excluding channels: {exclude}")
        else:
            exclude = []

        if len(args.channels) > 0:
            fs = c.user(args.channels)
        else:
            fs = list(filter(lambda f: f.user_name.lower() not in exclude, c.me.following()))

        vs = []
        if args.since is not None and args.since != 0:
            since = datetime.now(timezone.utc) - timedelta(days=args.since)
            with concurrent.futures.ThreadPoolExecutor(max_workers=20) as ex:
                for f in [ ex.submit(lambda f: f.videos(since=since), f) for f in fs ]:
                    vs += f.result()
            vs = sorted(vs, key=lambda v: v.created_at, reverse=True)

        if args.json:
            print(json.dumps([v.to_dict() for v in vs ]))
            sys.exit(0)

        def clean_title(t):
            t = t.replace('\n', ' ')
            t = t.encode("ascii", "ignore")
            return str(t[:args.title_max_length], "ascii")

        choices = []
        for s in c.streams(fs):
            choices.append(((s.user.user_name, "", "", clean_title(s.title)), s.url))
        for v in vs:
            choices.append(((v.user.user_name, render_duration(v.duration), v.typ[0], clean_title(v.title)), v.url))

        if args.menu:
            for c in dmenu(choices, lines=args.menu_lines): print(c)
        else:
            for l in tabularize([r for (r, u) in choices]): print(l)

    elif args.command == "stream" and args.stream_action == "set-title":
        c.me.channel.status = args.title
    elif args.command == "stream" and args.stream_action == "edit-title":
        c.me.channel.status = edit(c.me.channel.status)
    elif args.command == "stream" and args.stream_action == "set-category":
        c.me.channel.game = args.category
    elif args.command == "stream" and args.stream_action == "edit-category":
        c.me.channel.game = edit(c.me.channel.game)
    elif args.command == "stream" and args.stream_action == "title":
        s = c.me.channel.status
        print(json.dumps(s) if args.json else s)
    elif args.command == "stream" and args.stream_action == "category":
        s = c.me.channel.game
        print(json.dumps(s) if args.json else s)
    elif args.command == "stream" and args.stream_action == "status":
        d = c.me.channel.to_dict()
        if args.json:
            print(json.dumps(d))
        else:
            for k, v in d.items():
                print(f"{k}: {v}")
    elif args.command == "comments":
        content = args.content[0]
        if args.output is None:
            f = sys.stdout
        else:
            with open(args.output, 'a'):
                os.utime(args.output, None)
            f = open(args.output, "w")

        us = c.user(content)
        if len(us) > 0:
            for u in us:
                run_task(asyncio.get_event_loop().create_task(
                    Chat.run(client=c, channels=[u], read_only=True, output=f, start=args.start, subtitles=True, duration=args.duration)
                ))
        else:
            for v in c.video(content):
                i = 0
                for c in v.comments:
                    f.write(c.srt(i, args.duration))
                    f.flush()
                    i += 1
    else:
        logger.error(f"unhandled command: {args.command}")
